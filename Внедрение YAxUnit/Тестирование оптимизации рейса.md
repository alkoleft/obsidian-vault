Изначально планировалось проверить разбора пакета Загрузить_typeCalculatedTrips, но оптимизация рейсов более сложный процесс и для его проверки необходимо выполнить сковозной тест начиная с отправки на расчет и заканчивая уже разбором контрольного пакета.

## Подготовка

изначально планировалось самостоятельно разобраться и написать тест без привлечения "знающих" людей, но это привело к написанию относительно бесполезных тестов.

Поэтому, сначала нужно собрать требования и разобраться в работе механизма. Что и было сделано, пообщавшись с разработчиками выяснил процесс отправки рейса на оптимизацию, на основании этого постараюсь сделать тест проверяющий основной сценарий:
1. Имеется рейс
2. Рейс отправляется в РЦ на оптимизацию
3. Из РЦ приходит ответ с данными оптимизированного рейса (не ясно что там может придти)
4. Приходит контрольный пакет

Проверка будет представлять из себя набор тестов, которые должны выполнится последовательно. Можно было бы сделать это одним тестом, но повышается его сложность. Разбивка на мелкие тесты повысит читаемость и даст возможность переиспользовать "шаги".

## Реализация

### ПересчитатьВРЦ

1. Я создал отдельный общий модуль `ОМ_СпецРасчетный_Оптимизация`, так как функциональность важная и сложная, думаю тестов будет не мало.
2. Добавил тест `ПересчитатьВРЦ`, который должен проверить отправку в РЦ, по аналогии с командой из формы рейса.

#### Написание теста
1. Создал метод, который создает рейс с помощью конструктора объекта, метод создает пустышку рейса с минимальным заполнением и поместил его в ОМ `ТестовыеДанные`
```bsl
Функция НовыйРейс() Экспорт
	
	ПериодНачалаРейс = ЮТест.Данные().СлучайнаяДатаВБудущем(7, "День");
	ПериодОкончанияРейс = ЮТест.Данные().СлучайнаяДатаПосле(ПериодНачалаРейс, 24, "часа");
	
	Возврат ЮТест.Данные().КонструкторОбъекта(Документы.Рейс)
		.Установить("ПериодНачалаРейс", ПериодНачалаРейс)
		.Установить("ПериодОкончанияРейс", ПериодОкончанияРейс)
		.ФикцияОбязательныхПолей()
		.Записать();
	
КонецФункции
```

2. Добавил в тест логику из формы документа по отправке в РЦ
 ```bsl
Процедура ПересчитатьВРЦ() Экспорт
	
	Рейс = ТестовыеДанные.НовыйРейс();
	
	РезультатПолученияДанныеРейсовПередОптимизацией = АРМЛогистаСписокРейсовСервер.ПолучитьДанныеРейсовПередОптимизацией(ЮТКоллекции.ЗначениеВМассиве(Рейс));
	Успешно = АРМЛогистаСписокРейсовСервер.ОтправитьРейсыВРЦНаОптимизацию(РезультатПолученияДанныеРейсовПередОптимизацией.ДанныеРейсовПередОптимизацией);
	
	ЮТест.ОжидаетЧто(Успешно)
		.ЭтоИстина();
	
КонецПроцедуры
```
3. Ожидаемо тест упал, добавил проверки для вызова первого метода
```bsl
	РезультатПолученияДанныеРейсовПередОптимизацией = АРМЛогистаСписокРейсовСервер.ПолучитьДанныеРейсовПередОптимизацией(ЮТКоллекции.ЗначениеВМассиве(Рейс));
	
	ЮТест.ОжидаетЧто(РезультатПолученияДанныеРейсовПередОптимизацией)
		.ИмеетТип("Структура")
		.Свойство("ДанныеРейсовПередОптимизацией").Заполнено()
		.Свойство("ПотребуетсяВводДанныхВручную").ЭтоЛожь()
		.Свойство("РейсыСНезавершеннымиЗагрузками").НеЗаполнено();
```

Прояснения не случилось, поэтому решил подробнее разобраться с каждым методом в цепочке. Метод `ПолучитьДанныеРейсовПередОптимизацией` использует данные из базы, которые потом обрабатываются. Для теста эти данные необходимо подготовить, а также нужно разобраться с логикой обработки, начну с нее.
Почему с постобработки? Потому, что создав данные для метода `ПолучитьДанныеРейсовПередОптимизацией` я все равно не могу нормально контролировать результат и мои ожидания не совпадут, потому что на них влияет неизученная еще мою часть, а именно логика постобработки. Поэтому сначала хочу изучить ее, а какой лучший способ изучить - протестировать.

При обработке используются данные методов `ПолучитьДанныеОСостоянииЗагрузкиРейсов` и `ПроверитьРейсыНаНезавершенныеЗагрузки`. Я напишу для этих методов тесты и пойму как они работают и что для них необходимо.

Создаю тест для `ПолучитьДанныеОСостоянииЗагрузкиРейсов` в ОМ `ОМ_АРМЛогистаСписокРейсовСервер` метод использует данные из 3х регистров и требует трех документов: Рейс, ЗаявкаЭкспедитора, ЗаданиеВодителю
```bsl
Процедура ПолучитьДанныеОСостоянииЗагрузкиРейсов() Экспорт
	
	Рейс = ТестовыеДанные.НовыйРейс();
	ЗаявкаЭкспедитора = ТестовыеДанные.НоваяЗаявкаЭкспедитора();
	ЗаданиеВодителю = ТестовыеДанные.НовоеЗаданиеВодителю();
	
	ЮТест.Данные().КонструкторОбъекта(РегистрыСведений.ЗаявкиЭкспедиторовПоРейсам)
		.Установить("Рейс", Рейс)
		.Установить("ЗаявкаЭкспедитора", ЗаявкаЭкспедитора)
		.Записать();
	
	ЮТест.Данные().КонструкторОбъекта(РегистрыСведений.ЗаявкиЭкспедиторовПоЗаданиямВодителям)
		.Установить("Рейс", Рейс)
		.Установить("ЗаявкаЭкспедитора", ЗаявкаЭкспедитора)
		.Установить("ЗаданиеВодителю", ЗаданиеВодителю)
		.Записать();
	
	ЮТест.Данные().КонструкторОбъекта(РегистрыСведений.СостоянияЗаявокЭкспедиторов)
		.Установить("ЗаявкаЭкспедитора", ЗаявкаЭкспедитора)
		.Установить("СостояниеЗаявки", ЗаданиеВодителю)
		.Записать();
	
	РезультатЗапроса = АРМЛогистаСписокРейсовСервер.ПолучитьДанныеОСостоянииЗагрузкиРейсов(ЮТКоллекции.ЗначениеВМассиве(Рейс));
	Данные = РезультатЗапроса.Выгрузить();
	
	ЮТест.ОжидаетЧто(Данные)
		.ИмеетДлину(3)
		.Свойство("[0].Рейс").Равно(Рейс);
	
КонецПроцедуры
```
Поймал ошибку получения "ЗначениеВнешнегоРеквизита", которая не работает если не заполнен справочник "ИменаРеквизитовДокументов", ошибка: `Синтаксическая ошибка "КАК" <>КАК Значени`, получается необходимо еще заполнить этот справочник.
Пришлось повозится с начальным заполнением (в будущем необходимо создать первоначальный образ базы с начальным заполнением).

В итоге создал набор методов для создания документов и первоначального заполнения
```bsl
Функция НовыйРейс() Экспорт
	
	ПериодНачалаРейс = ЮТест.Данные().СлучайнаяДатаВБудущем(7, "День");
	ПериодОкончанияРейс = ЮТест.Данные().СлучайнаяДатаПосле(ПериодНачалаРейс, 24, "часа");
	
	Возврат ЮТест.Данные().КонструкторОбъекта(Документы.Рейс)
		.Установить("ПериодНачалаРейс", ПериодНачалаРейс)
		.Установить("ПериодОкончанияРейс", ПериодОкончанияРейс)
		.ФикцияОбязательныхПолей()
		.Провести();
	
КонецФункции

Функция НоваяЗаявкаЭкспедитора(Рейс) Экспорт
	
	Контрагент = ЮТест.Данные().СоздатьЭлемент(Справочники.Контрагенты);
	АдресДоставки = НовыйАдрес(Контрагент);
	ДополнительныйАдресДоставки = НовыйАдрес(Контрагент);
	
	Заявка = ЮТест.Данные().КонструкторОбъекта(Документы.ЗаявкаЭкспедитора)
		.ФикцияОбязательныхПолей()
		.Фикция("ДатаИсполнения")
		.Фикция("ВидУслуги")
		.Фикция("ТипЗаявки")
		.Фикция("ГородОтправитель")
		.Фикция("ГородПолучатель")
		.Фикция("ВремяДоставкиОт")
		.Установить("КонтрагентОтправитель", Контрагент)
		.Установить("КонтрагентПолучатель", Контрагент)
		.Установить("КонтрагентОтправительАдресДоставки", АдресДоставки)
		.Установить("КонтрагентПолучательАдресДоставки", АдресДоставки)
		.Установить("ДополнительныйАдресДоставкиОтправителя", ДополнительныйАдресДоставки)
		.Фикция("ВремяДоставкиОт")
		.Фикция("ВремяДоставкиДо")
		.Провести();
	
	УправлениеСтатусамиЗаявок.АктуализироватьТекущийСтатус(Заявка, "Планирование", , , Рейс);
	
	
	ЮТест.Данные().КонструкторОбъекта(РегистрыСведений.ЗаявкиЭкспедиторовПоРейсам)
		.Установить("Рейс", Рейс)
		.Установить("ЗаявкаЭкспедитора", Заявка)
		.Записать();
	
	Возврат Заявка;
	
КонецФункции

Функция НовоеЗаданиеВодителю() Экспорт
	
	Возврат ЮТест.Данные().КонструкторОбъекта(Документы.ЗаданиеВодителю)
		.ФикцияОбязательныхПолей()
		.Установить("Состояние", Справочники.СостоянияДокументов.ЗаданиеВодителюЗапланировано)
		.Провести();
	
КонецФункции

Функция НачальноеЗаполнение() Экспорт
	
	ТипыРеквизитов = ПланыВидовХарактеристик.ТипыРеквизитовСправочниковДокументов;
	ИменаРеквизитов = Справочники.ИменаРеквизитовДокументов;
	ЮТест.Данные().УстановитьЗначениеРеквизита(ТипыРеквизитов.Булево, "ИмяРесурсаЗначения", "ЗначениеБулево");
	
	БулевыеРеквизиты = ЮТКоллекции.ЗначениеВМассиве(
		ИменаРеквизитов.ОтключитьФункциюФиксированныйСрокДоставкиПоНаправлению,
		ИменаРеквизитов.ФиксированныйСрокДоставкиПоНаправлениюДляЗабора,
		ИменаРеквизитов.ЗаявкаЭкспедитораОсновнойВодительЕздилБезГрузчика);
	Настройки = Новый Структура("ВидРеквизита, ЗначениеПоУмолчанию", ТипыРеквизитов.Булево, Ложь);
	
	Для Каждого ИмяРеквизита Из БулевыеРеквизиты Цикл
		ЮТест.Данные().УстановитьЗначенияРеквизитов(ИмяРеквизита, Настройки);
	КонецЦикла;
	
КонецФункции

Функция НовыйАдрес(Владелец) Экспорт
	
	ЮТест.Данные().КонструкторОбъекта(Справочники.КонтактнаяИнформация)
		.Установить("Владелец", Владелец)
		.Фикция("Адрес")
		.ФикцияОбязательныхПолей()
		.Записать();
	
КонецФункции
```

А тест стал выглядеть вот так:
```bsl
Процедура ИсполняемыеСценарии() Экспорт
	
	ЮТТесты.Перед("НачальноеЗаполнение").ВТранзакции()
		.ДобавитьТест("ПолучитьДанныеОСостоянииЗагрузкиРейсов")
	;
	
КонецПроцедуры

Процедура НачальноеЗаполнение() Экспорт
	
	ТестовыеДанные.НачальноеЗаполнение();
	
КонецПроцедуры

Процедура ПолучитьДанныеОСостоянииЗагрузкиРейсов() Экспорт
	
	Рейс = ТестовыеДанные.НовыйРейс();
	ЗаявкаЭкспедитора = ТестовыеДанные.НоваяЗаявкаЭкспедитора(Рейс);
	ЗаданиеВодителю = ТестовыеДанные.НовоеЗаданиеВодителю();
	
	ЮТест.Данные().КонструкторОбъекта(РегистрыСведений.ЗаявкиЭкспедиторовПоЗаданиямВодителям)
		.Установить("Рейс", Рейс)
		.Установить("ЗаявкаЭкспедитора", ЗаявкаЭкспедитора)
		.Установить("ЗаданиеВодителю", ЗаданиеВодителю)
		.Установить("ТипЗадания", Справочники.ТипыЗаданийВодителю.ЗагрузкаНаСкладе)
		.Записать();
	
	РезультатЗапроса = АРМЛогистаСписокРейсовСервер.ПолучитьДанныеОСостоянииЗагрузкиРейсов(ЮТКоллекции.ЗначениеВМассиве(Рейс));
	Данные = РезультатЗапроса.Выгрузить();
	
	ЮТест.ОжидаетЧто(Данные)
		.ИмеетДлину(3)
		.Свойство("[0].Рейс").Равно(Рейс)
		.Свойство("[1].ЗаданиеВодителю").Равно(ЗаданиеВодителю)
		.Свойство("[2].ЗаявкаНеЗагружена").ЭтоИстина();
	
КонецПроцедуры
```

Возвращаемся к первоначальному тесту `ПересчитатьВРЦ`, перенесем в него подготовку данных из `ПолучитьДанныеОСостоянииЗагрузкиРейсов`. Запускаем тест и он падает, нехватает данных. С помощью отладки и такой то матери спустя два часа мне удалось подготовить все необходимые данные для отправки рейса в РЦ.

Для рейса пришлось добавить заполнение реквизитов
```bsl
Функция НовыйРейс() Экспорт
	
	ПериодНачалаРейс = ЮТест.Данные().СлучайнаяДатаВБудущем(7, "День");
	ПериодОкончанияРейс = ЮТест.Данные().СлучайнаяДатаПосле(ПериодНачалаРейс, 24, "часа");
	
	Возврат ЮТест.Данные().КонструкторОбъекта(Документы.Рейс)
		.Установить("ПериодНачалаРейс", ПериодНачалаРейс)
		.Установить("ПериодОкончанияРейс", ПериодОкончанияРейс)
		.Фикция("ТипТС") // Добавлено
		.Фикция("ОсновнойВодитель") // Добавлено
		.Фикция("Машина") // Добавлено
		.ФикцияОбязательныхПолей()
		.Провести();
	
КонецФункции
```
И установку доступности водителей на период рейса.
Для заявки экспедитору - установку сегмента. 

После подготовки минимально необходимого набора данных тест стал падать на отправке в шину, но тут на помощь приходит мокито. Мокируем метод отправки и все отправка на пересчет позеленела.

Получившийся тест
```bsl
Процедура ПересчитатьВРЦ() Экспорт
	
	Рейс = ТестовыеДанные.НовыйРейс();
	ЗаявкаЭкспедитора = ТестовыеДанные.НоваяЗаявкаЭкспедитора(Рейс);
	ЗаданиеВодителю = ТестовыеДанные.НовоеЗаданиеВодителю();
	
	ТестовыеДанные.УстановитьДанныеДоступностиВодителей(Рейс);
	
	ЮТест.Данные().КонструкторОбъекта(РегистрыСведений.ЗаявкиЭкспедиторовПоЗаданиямВодителям)
		.Установить("Рейс", Рейс)
		.Установить("ЗаявкаЭкспедитора", ЗаявкаЭкспедитора)
		.Установить("ЗаданиеВодителю", ЗаданиеВодителю)
		.Установить("ТипЗадания", Справочники.ТипыЗаданийВодителю.ЗагрузкаНаСкладе)
		.Записать();
	
	РезультатПолученияДанныеРейсовПередОптимизацией = АРМЛогистаСписокРейсовСервер.ПолучитьДанныеРейсовПередОптимизацией(ЮТКоллекции.ЗначениеВМассиве(Рейс));
	
	ЮТест.ОжидаетЧто(РезультатПолученияДанныеРейсовПередОптимизацией)
		.ИмеетТип("Структура")
		.Свойство("ДанныеРейсовПередОптимизацией").Заполнено()
		.Свойство("ПотребуетсяВводДанныхВручную").ЭтоЛожь()
		.Свойство("РейсыСНезавершеннымиЗагрузками").НеЗаполнено();
	
	Мокито.Обучение(УправляемыеСервисы)
		.Когда("Сервис_ОтправкаРейсаВРЦНаОптимизацию").Вернуть(Новый Структура("Выполнено", Истина))
		.Прогон();
	
	Успешно = АРМЛогистаСписокРейсовСервер.ОтправитьРейсыВРЦНаОптимизацию(РезультатПолученияДанныеРейсовПередОптимизацией.ДанныеРейсовПередОптимизацией);
	
	ЮТест.ОжидаетЧто(Успешно)
		.ЭтоИстина();
	
КонецПроцедуры
```

